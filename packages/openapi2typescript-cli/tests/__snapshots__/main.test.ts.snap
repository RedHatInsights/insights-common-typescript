// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`src/cli/schema execute for ./tests/__fixtures__/integrations-openapi.json execute accepts urls 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidatedResponse } from 'openapi2typescript';
import { Action } from 'react-fetching-library';
import { ValidateRule } from 'openapi2typescript';
import {
    actionBuilder,
    ActionValidatableConfig
} from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Application = zodSchemaApplication();
  export type Application = z.infer<typeof Application>;

  export const Attributes = zodSchemaAttributes();
  export type Attributes = z.infer<typeof Attributes>;

  export const BasicAuthentication = zodSchemaBasicAuthentication();
  export type BasicAuthentication = z.infer<typeof BasicAuthentication>;

  export const Date = zodSchemaDate();
  export type Date = z.infer<typeof Date>;

  export const EmailAttributes = zodSchemaEmailAttributes();
  export type EmailAttributes = z.infer<typeof EmailAttributes>;

  export const Endpoint = zodSchemaEndpoint();
  export type Endpoint = z.infer<typeof Endpoint>;

  export const EndpointType = zodSchemaEndpointType();
  export type EndpointType = z.infer<typeof EndpointType>;

  export const EntityTag = zodSchemaEntityTag();
  export type EntityTag = z.infer<typeof EntityTag>;

  export const EventType = zodSchemaEventType();
  export type EventType = z.infer<typeof EventType>;

  export const Family = zodSchemaFamily();
  export type Family = z.infer<typeof Family>;

  export const HttpType = zodSchemaHttpType();
  export type HttpType = z.infer<typeof HttpType>;

  export const JsonObject = zodSchemaJsonObject();
  export type JsonObject = z.infer<typeof JsonObject>;

  export const Link = zodSchemaLink();
  export type Link = z.infer<typeof Link>;

  export const ListString = zodSchemaListString();
  export type ListString = z.infer<typeof ListString>;

  export const Locale = zodSchemaLocale();
  export type Locale = z.infer<typeof Locale>;

  export const MapStringNewCookie = zodSchemaMapStringNewCookie();
  export type MapStringNewCookie = z.infer<typeof MapStringNewCookie>;

  export const MapStringString = zodSchemaMapStringString();
  export type MapStringString = z.infer<typeof MapStringString>;

  export const MediaType = zodSchemaMediaType();
  export type MediaType = z.infer<typeof MediaType>;

  export const MultivaluedMapStringObject = zodSchemaMultivaluedMapStringObject();
  export type MultivaluedMapStringObject = z.infer<
    typeof MultivaluedMapStringObject
  >;

  export const MultivaluedMapStringString = zodSchemaMultivaluedMapStringString();
  export type MultivaluedMapStringString = z.infer<
    typeof MultivaluedMapStringString
  >;

  export const NewCookie = zodSchemaNewCookie();
  export type NewCookie = z.infer<typeof NewCookie>;

  export const Notification = zodSchemaNotification();
  export type Notification = z.infer<typeof Notification>;

  export const NotificationHistory = zodSchemaNotificationHistory();
  export type NotificationHistory = z.infer<typeof NotificationHistory>;

  export const Response = zodSchemaResponse();
  export type Response = z.infer<typeof Response>;

  export const SetCharacter = zodSchemaSetCharacter();
  export type SetCharacter = z.infer<typeof SetCharacter>;

  export const SetEndpoint = zodSchemaSetEndpoint();
  export type SetEndpoint = z.infer<typeof SetEndpoint>;

  export const SetEventType = zodSchemaSetEventType();
  export type SetEventType = z.infer<typeof SetEventType>;

  export const SetLink = zodSchemaSetLink();
  export type SetLink = z.infer<typeof SetLink>;

  export const SetString = zodSchemaSetString();
  export type SetString = z.infer<typeof SetString>;

  export const StatusType = zodSchemaStatusType();
  export type StatusType = z.infer<typeof StatusType>;

  export const URI = zodSchemaURI();
  export type URI = z.infer<typeof URI>;

  export const UUID = zodSchemaUUID();
  export type UUID = z.infer<typeof UUID>;

  export const UriBuilder = zodSchemaUriBuilder();
  export type UriBuilder = z.infer<typeof UriBuilder>;

  export const WebhookAttributes = zodSchemaWebhookAttributes();
  export type WebhookAttributes = z.infer<typeof WebhookAttributes>;

  function zodSchemaApplication() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          description: z.string(),
          eventTypes: zodSchemaSetEventType().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: zodSchemaDate().optional().nullable()
      });
  }

  function zodSchemaAttributes() {
      return z.unknown();
  }

  function zodSchemaBasicAuthentication() {
      return z.object({
          password: z.string().optional().nullable(),
          username: z.string().optional().nullable()
      });
  }

  function zodSchemaDate() {
      return z.string();
  }

  function zodSchemaEmailAttributes() {
      return z.unknown();
  }

  function zodSchemaEndpoint() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          description: z.string(),
          enabled: z.boolean().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          properties: z
          .union([ zodSchemaWebhookAttributes(), zodSchemaEmailAttributes() ])
          .optional()
          .nullable(),
          type: z.intersection(
              zodSchemaEndpointType(),
              z.enum([ 'webhook', 'email', 'default' ])
          ),
          updated: zodSchemaDate().optional().nullable()
      });
  }

  function zodSchemaEndpointType() {
      return z.enum([ 'webhook', 'email', 'default' ]);
  }

  function zodSchemaEntityTag() {
      return z.object({
          value: z.string().optional().nullable(),
          weak: z.boolean().optional().nullable()
      });
  }

  function zodSchemaEventType() {
      return z.object({
          application: z
          .lazy(() => zodSchemaApplication())
          .optional()
          .nullable(),
          description: z.string(),
          endpoints: zodSchemaSetEndpoint().optional().nullable(),
          id: z.number().int().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaFamily() {
      return z.enum([
          'CLIENT_ERROR',
          'INFORMATIONAL',
          'OTHER',
          'REDIRECTION',
          'SERVER_ERROR',
          'SUCCESSFUL'
      ]);
  }

  function zodSchemaHttpType() {
      return z.enum([ 'GET', 'POST', 'PUT' ]);
  }

  function zodSchemaJsonObject() {
      return z.array(z.unknown());
  }

  function zodSchemaLink() {
      return z.object({
          params: zodSchemaMapStringString().optional().nullable(),
          rel: z.string().optional().nullable(),
          rels: zodSchemaListString().optional().nullable(),
          title: z.string().optional().nullable(),
          type: z.string().optional().nullable(),
          uri: zodSchemaURI().optional().nullable(),
          uriBuilder: zodSchemaUriBuilder().optional().nullable()
      });
  }

  function zodSchemaListString() {
      return z.array(z.string());
  }

  function zodSchemaLocale() {
      return z.object({
          country: z.string().optional().nullable(),
          displayCountry: z.string().optional().nullable(),
          displayLanguage: z.string().optional().nullable(),
          displayName: z.string().optional().nullable(),
          displayScript: z.string().optional().nullable(),
          displayVariant: z.string().optional().nullable(),
          extensionKeys: zodSchemaSetCharacter().optional().nullable(),
          iSO3Country: z.string().optional().nullable(),
          iSO3Language: z.string().optional().nullable(),
          language: z.string().optional().nullable(),
          script: z.string().optional().nullable(),
          unicodeLocaleAttributes: zodSchemaSetString().optional().nullable(),
          unicodeLocaleKeys: zodSchemaSetString().optional().nullable(),
          variant: z.string().optional().nullable()
      });
  }

  function zodSchemaMapStringNewCookie() {
      return z.record(zodSchemaNewCookie());
  }

  function zodSchemaMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaMediaType() {
      return z.object({
          parameters: zodSchemaMapStringString().optional().nullable(),
          subtype: z.string().optional().nullable(),
          type: z.string().optional().nullable(),
          wildcardSubtype: z.boolean().optional().nullable(),
          wildcardType: z.boolean().optional().nullable()
      });
  }

  function zodSchemaMultivaluedMapStringObject() {
      return z.record(z.unknown());
  }

  function zodSchemaMultivaluedMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaNewCookie() {
      return z.object({
          comment: z.string().optional().nullable(),
          domain: z.string().optional().nullable(),
          expiry: zodSchemaDate().optional().nullable(),
          httpOnly: z.boolean().optional().nullable(),
          maxAge: z.number().int().optional().nullable(),
          name: z.string().optional().nullable(),
          path: z.string().optional().nullable(),
          secure: z.boolean().optional().nullable(),
          value: z.string().optional().nullable(),
          version: z.number().int().optional().nullable()
      });
  }

  function zodSchemaNotification() {
      return z.object({
          endpoint: zodSchemaEndpoint().optional().nullable(),
          payload: z.unknown().optional().nullable(),
          tenant: z.string().optional().nullable()
      });
  }

  function zodSchemaNotificationHistory() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          details: zodSchemaJsonObject().optional().nullable(),
          endpointId: zodSchemaUUID().optional().nullable(),
          id: z.number().int().optional().nullable(),
          invocationResult: z.boolean().optional().nullable(),
          invocationTime: z.number().int().optional().nullable()
      });
  }

  function zodSchemaResponse() {
      return z.object({
          allowedMethods: zodSchemaSetString().optional().nullable(),
          cookies: zodSchemaMapStringNewCookie().optional().nullable(),
          date: zodSchemaDate().optional().nullable(),
          entity: z.unknown().optional().nullable(),
          entityTag: zodSchemaEntityTag().optional().nullable(),
          headers: zodSchemaMultivaluedMapStringObject().optional().nullable(),
          language: zodSchemaLocale().optional().nullable(),
          lastModified: zodSchemaDate().optional().nullable(),
          length: z.number().int().optional().nullable(),
          links: zodSchemaSetLink().optional().nullable(),
          location: zodSchemaURI().optional().nullable(),
          mediaType: zodSchemaMediaType().optional().nullable(),
          metadata: zodSchemaMultivaluedMapStringObject().optional().nullable(),
          status: z.number().int().optional().nullable(),
          statusInfo: zodSchemaStatusType().optional().nullable(),
          stringHeaders: zodSchemaMultivaluedMapStringString()
          .optional()
          .nullable()
      });
  }

  function zodSchemaSetCharacter() {
      return z.array(z.string());
  }

  function zodSchemaSetEndpoint() {
      return z.array(zodSchemaEndpoint());
  }

  function zodSchemaSetEventType() {
      return z.array(zodSchemaEventType());
  }

  function zodSchemaSetLink() {
      return z.array(zodSchemaLink());
  }

  function zodSchemaSetString() {
      return z.array(z.string());
  }

  function zodSchemaStatusType() {
      return z.object({
          family: zodSchemaFamily().optional().nullable(),
          reasonPhrase: z.string().optional().nullable(),
          statusCode: z.number().int().optional().nullable()
      });
  }

  function zodSchemaURI() {
      return z.string();
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchemaUriBuilder() {
      return z.unknown();
  }

  function zodSchemaWebhookAttributes() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean().optional().nullable(),
          method: z.intersection(
              zodSchemaHttpType(),
              z.enum([ 'GET', 'POST', 'PUT' ])
          ),
          secret_token: z.string().optional().nullable(),
          url: z.string()
      });
  }
}

export namespace Operations {
  // GET /endpoints
  export namespace EndpointServiceGetEndpoints {
    const Active = z.boolean();
    type Active = z.infer<typeof Active>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const PageNumber = z.number().int();
    type PageNumber = z.infer<typeof PageNumber>;
    const SortBy = z.string();
    type SortBy = z.infer<typeof SortBy>;
    const Type = z.string();
    type Type = z.infer<typeof Type>;
    const Response200 = z.array(Schemas.Endpoint);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      active?: Active;
      limit?: Limit;
      offset?: Offset;
      pageNumber?: PageNumber;
      sortBy?: SortBy;
      type?: Type;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints';
        const query = {} as Record<string, any>;
        if (params.active !== undefined) {
            query.active = params.active;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        if (params.type !== undefined) {
            query.type = params.type;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // POST /endpoints
  export namespace EndpointServiceCreateEndpoint {
    export interface Params {
      body: Schemas.Endpoint;
    }

    export type Payload =
      | ValidatedResponse<'Endpoint', 200, Schemas.Endpoint>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Schemas.Endpoint, 'Endpoint', 200) ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}
  export namespace EndpointServiceGetEndpoint {
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Endpoint', 200, Schemas.Endpoint>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.Endpoint, 'Endpoint', 200) ]
        })
        .build();
    };
  }
  // PUT /endpoints/{id}
  export namespace EndpointServiceUpdateEndpoint {
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
      body: Schemas.Endpoint;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // DELETE /endpoints/{id}
  export namespace EndpointServiceDeleteEndpoint {
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // PUT /endpoints/{id}/enable
  export namespace EndpointServiceEnableEndpoint {
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // DELETE /endpoints/{id}/enable
  export namespace EndpointServiceDisableEndpoint {
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}/history
  export namespace EndpointServiceGetEndpointHistory {
    const Response200 = z.array(Schemas.NotificationHistory);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}/history'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}/history/{history_id}/details
  export namespace EndpointServiceGetDetailedEndpointHistory {
    const HistoryId = z.number().int();
    type HistoryId = z.infer<typeof HistoryId>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const PageNumber = z.number().int();
    type PageNumber = z.infer<typeof PageNumber>;
    const PageSize = z.number().int();
    type PageSize = z.infer<typeof PageSize>;
    const SortBy = z.string();
    type SortBy = z.infer<typeof SortBy>;
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      historyId: HistoryId;
      id: Schemas.UUID;
      limit?: Limit;
      offset?: Offset;
      pageNumber?: PageNumber;
      pageSize?: PageSize;
      sortBy?: SortBy;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/integrations/v1.0/endpoints/{id}/history/{history_id}/details'
        .replace('{history_id}', params.historyId.toString())
        .replace('{id}', params.id.toString());
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.pageSize !== undefined) {
            query.pageSize = params.pageSize;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/integrations-openapi.json execute input file accepts path 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidateRule } from 'openapi2typescript';
import { actionBuilder } from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Application = zodSchemaApplication();

  export const Attributes = zodSchemaAttributes();

  export const BasicAuthentication = zodSchemaBasicAuthentication();

  export const Date = zodSchemaDate();

  export const EmailAttributes = zodSchemaEmailAttributes();

  export const Endpoint = zodSchemaEndpoint();

  export const EndpointType = zodSchemaEndpointType();

  export const EntityTag = zodSchemaEntityTag();

  export const EventType = zodSchemaEventType();

  export const Family = zodSchemaFamily();

  export const HttpType = zodSchemaHttpType();

  export const JsonObject = zodSchemaJsonObject();

  export const Link = zodSchemaLink();

  export const ListString = zodSchemaListString();

  export const Locale = zodSchemaLocale();

  export const MapStringNewCookie = zodSchemaMapStringNewCookie();

  export const MapStringString = zodSchemaMapStringString();

  export const MediaType = zodSchemaMediaType();

  export const MultivaluedMapStringObject = zodSchemaMultivaluedMapStringObject();

  export const MultivaluedMapStringString = zodSchemaMultivaluedMapStringString();

  export const NewCookie = zodSchemaNewCookie();

  export const Notification = zodSchemaNotification();

  export const NotificationHistory = zodSchemaNotificationHistory();

  export const Response = zodSchemaResponse();

  export const SetCharacter = zodSchemaSetCharacter();

  export const SetEndpoint = zodSchemaSetEndpoint();

  export const SetEventType = zodSchemaSetEventType();

  export const SetLink = zodSchemaSetLink();

  export const SetString = zodSchemaSetString();

  export const StatusType = zodSchemaStatusType();

  export const URI = zodSchemaURI();

  export const UUID = zodSchemaUUID();

  export const UriBuilder = zodSchemaUriBuilder();

  export const WebhookAttributes = zodSchemaWebhookAttributes();

  function zodSchemaApplication() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          description: z.string(),
          eventTypes: zodSchemaSetEventType().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: zodSchemaDate().optional().nullable()
      });
  }

  function zodSchemaAttributes() {
      return z.unknown();
  }

  function zodSchemaBasicAuthentication() {
      return z.object({
          password: z.string().optional().nullable(),
          username: z.string().optional().nullable()
      });
  }

  function zodSchemaDate() {
      return z.string();
  }

  function zodSchemaEmailAttributes() {
      return z.unknown();
  }

  function zodSchemaEndpoint() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          description: z.string(),
          enabled: z.boolean().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          properties: z
          .union([ zodSchemaWebhookAttributes(), zodSchemaEmailAttributes() ])
          .optional()
          .nullable(),
          type: z.intersection(
              zodSchemaEndpointType(),
              z.enum([ 'webhook', 'email', 'default' ])
          ),
          updated: zodSchemaDate().optional().nullable()
      });
  }

  function zodSchemaEndpointType() {
      return z.enum([ 'webhook', 'email', 'default' ]);
  }

  function zodSchemaEntityTag() {
      return z.object({
          value: z.string().optional().nullable(),
          weak: z.boolean().optional().nullable()
      });
  }

  function zodSchemaEventType() {
      return z.object({
          application: z
          .lazy(() => zodSchemaApplication())
          .optional()
          .nullable(),
          description: z.string(),
          endpoints: zodSchemaSetEndpoint().optional().nullable(),
          id: z.number().int().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaFamily() {
      return z.enum([
          'CLIENT_ERROR',
          'INFORMATIONAL',
          'OTHER',
          'REDIRECTION',
          'SERVER_ERROR',
          'SUCCESSFUL'
      ]);
  }

  function zodSchemaHttpType() {
      return z.enum([ 'GET', 'POST', 'PUT' ]);
  }

  function zodSchemaJsonObject() {
      return z.array(z.unknown());
  }

  function zodSchemaLink() {
      return z.object({
          params: zodSchemaMapStringString().optional().nullable(),
          rel: z.string().optional().nullable(),
          rels: zodSchemaListString().optional().nullable(),
          title: z.string().optional().nullable(),
          type: z.string().optional().nullable(),
          uri: zodSchemaURI().optional().nullable(),
          uriBuilder: zodSchemaUriBuilder().optional().nullable()
      });
  }

  function zodSchemaListString() {
      return z.array(z.string());
  }

  function zodSchemaLocale() {
      return z.object({
          country: z.string().optional().nullable(),
          displayCountry: z.string().optional().nullable(),
          displayLanguage: z.string().optional().nullable(),
          displayName: z.string().optional().nullable(),
          displayScript: z.string().optional().nullable(),
          displayVariant: z.string().optional().nullable(),
          extensionKeys: zodSchemaSetCharacter().optional().nullable(),
          iSO3Country: z.string().optional().nullable(),
          iSO3Language: z.string().optional().nullable(),
          language: z.string().optional().nullable(),
          script: z.string().optional().nullable(),
          unicodeLocaleAttributes: zodSchemaSetString().optional().nullable(),
          unicodeLocaleKeys: zodSchemaSetString().optional().nullable(),
          variant: z.string().optional().nullable()
      });
  }

  function zodSchemaMapStringNewCookie() {
      return z.record(zodSchemaNewCookie());
  }

  function zodSchemaMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaMediaType() {
      return z.object({
          parameters: zodSchemaMapStringString().optional().nullable(),
          subtype: z.string().optional().nullable(),
          type: z.string().optional().nullable(),
          wildcardSubtype: z.boolean().optional().nullable(),
          wildcardType: z.boolean().optional().nullable()
      });
  }

  function zodSchemaMultivaluedMapStringObject() {
      return z.record(z.unknown());
  }

  function zodSchemaMultivaluedMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaNewCookie() {
      return z.object({
          comment: z.string().optional().nullable(),
          domain: z.string().optional().nullable(),
          expiry: zodSchemaDate().optional().nullable(),
          httpOnly: z.boolean().optional().nullable(),
          maxAge: z.number().int().optional().nullable(),
          name: z.string().optional().nullable(),
          path: z.string().optional().nullable(),
          secure: z.boolean().optional().nullable(),
          value: z.string().optional().nullable(),
          version: z.number().int().optional().nullable()
      });
  }

  function zodSchemaNotification() {
      return z.object({
          endpoint: zodSchemaEndpoint().optional().nullable(),
          payload: z.unknown().optional().nullable(),
          tenant: z.string().optional().nullable()
      });
  }

  function zodSchemaNotificationHistory() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          details: zodSchemaJsonObject().optional().nullable(),
          endpointId: zodSchemaUUID().optional().nullable(),
          id: z.number().int().optional().nullable(),
          invocationResult: z.boolean().optional().nullable(),
          invocationTime: z.number().int().optional().nullable()
      });
  }

  function zodSchemaResponse() {
      return z.object({
          allowedMethods: zodSchemaSetString().optional().nullable(),
          cookies: zodSchemaMapStringNewCookie().optional().nullable(),
          date: zodSchemaDate().optional().nullable(),
          entity: z.unknown().optional().nullable(),
          entityTag: zodSchemaEntityTag().optional().nullable(),
          headers: zodSchemaMultivaluedMapStringObject().optional().nullable(),
          language: zodSchemaLocale().optional().nullable(),
          lastModified: zodSchemaDate().optional().nullable(),
          length: z.number().int().optional().nullable(),
          links: zodSchemaSetLink().optional().nullable(),
          location: zodSchemaURI().optional().nullable(),
          mediaType: zodSchemaMediaType().optional().nullable(),
          metadata: zodSchemaMultivaluedMapStringObject().optional().nullable(),
          status: z.number().int().optional().nullable(),
          statusInfo: zodSchemaStatusType().optional().nullable(),
          stringHeaders: zodSchemaMultivaluedMapStringString()
          .optional()
          .nullable()
      });
  }

  function zodSchemaSetCharacter() {
      return z.array(z.string());
  }

  function zodSchemaSetEndpoint() {
      return z.array(zodSchemaEndpoint());
  }

  function zodSchemaSetEventType() {
      return z.array(zodSchemaEventType());
  }

  function zodSchemaSetLink() {
      return z.array(zodSchemaLink());
  }

  function zodSchemaSetString() {
      return z.array(z.string());
  }

  function zodSchemaStatusType() {
      return z.object({
          family: zodSchemaFamily().optional().nullable(),
          reasonPhrase: z.string().optional().nullable(),
          statusCode: z.number().int().optional().nullable()
      });
  }

  function zodSchemaURI() {
      return z.string();
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchemaUriBuilder() {
      return z.unknown();
  }

  function zodSchemaWebhookAttributes() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean().optional().nullable(),
          method: z.intersection(
              zodSchemaHttpType(),
              z.enum([ 'GET', 'POST', 'PUT' ])
          ),
          secret_token: z.string().optional().nullable(),
          url: z.string()
      });
  }
}

export namespace Operations {
  // GET /endpoints
  export namespace EndpointServiceGetEndpoints {
    const Active = z.boolean();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const PageNumber = z.number().int();
    const SortBy = z.string();
    const Type = z.string();
    const Response200 = z.array(Schemas.Endpoint);
    /*
 Params
'active'?:Active,
'limit'?:Limit,
'offset'?:Offset,
'pageNumber'?:PageNumber,
'sortBy'?:SortBy,
'type'?:Type
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints';
        const query = {};
        if (params.active !== undefined) {
            query.active = params.active;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        if (params.type !== undefined) {
            query.type = params.type;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // POST /endpoints
  export namespace EndpointServiceCreateEndpoint {
    /*
 Params
body: Schemas.Endpoint
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Schemas.Endpoint, 'Endpoint', 200) ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}
  export namespace EndpointServiceGetEndpoint {
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.Endpoint, 'Endpoint', 200) ]
        })
        .build();
    };
  }
  // PUT /endpoints/{id}
  export namespace EndpointServiceUpdateEndpoint {
    const Response200 = z.string();
    /*
 Params
'id':Schemas.UUID,
body: Schemas.Endpoint
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // DELETE /endpoints/{id}
  export namespace EndpointServiceDeleteEndpoint {
    const Response200 = z.string();
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // PUT /endpoints/{id}/enable
  export namespace EndpointServiceEnableEndpoint {
    const Response200 = z.string();
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // DELETE /endpoints/{id}/enable
  export namespace EndpointServiceDisableEndpoint {
    const Response200 = z.string();
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}/enable'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}/history
  export namespace EndpointServiceGetEndpointHistory {
    const Response200 = z.array(Schemas.NotificationHistory);
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}/history'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // GET /endpoints/{id}/history/{history_id}/details
  export namespace EndpointServiceGetDetailedEndpointHistory {
    const HistoryId = z.number().int();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const PageNumber = z.number().int();
    const PageSize = z.number().int();
    const SortBy = z.string();
    const Response200 = z.string();
    /*
 Params
'historyId':HistoryId,
'id':Schemas.UUID,
'limit'?:Limit,
'offset'?:Offset,
'pageNumber'?:PageNumber,
'pageSize'?:PageSize,
'sortBy'?:SortBy
*/
    export const actionCreator = (params) => {
        const path = '/api/integrations/v1.0/endpoints/{id}/history/{history_id}/details'
        .replace('{history_id}', params.historyId.toString())
        .replace('{id}', params.id.toString());
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.pageSize !== undefined) {
            query.pageSize = params.pageSize;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/notifications-openapi.json execute accepts urls 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidatedResponse } from 'openapi2typescript';
import { Action } from 'react-fetching-library';
import { ValidateRule } from 'openapi2typescript';
import {
    actionBuilder,
    ActionValidatableConfig
} from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Application = zodSchemaApplication();
  export type Application = z.infer<typeof Application>;

  export const Attributes = zodSchemaAttributes();
  export type Attributes = z.infer<typeof Attributes>;

  export const BasicAuthentication = zodSchemaBasicAuthentication();
  export type BasicAuthentication = z.infer<typeof BasicAuthentication>;

  export const Date = zodSchemaDate();
  export type Date = z.infer<typeof Date>;

  export const EmailAttributes = zodSchemaEmailAttributes();
  export type EmailAttributes = z.infer<typeof EmailAttributes>;

  export const Endpoint = zodSchemaEndpoint();
  export type Endpoint = z.infer<typeof Endpoint>;

  export const EndpointType = zodSchemaEndpointType();
  export type EndpointType = z.infer<typeof EndpointType>;

  export const EntityTag = zodSchemaEntityTag();
  export type EntityTag = z.infer<typeof EntityTag>;

  export const EventType = zodSchemaEventType();
  export type EventType = z.infer<typeof EventType>;

  export const Family = zodSchemaFamily();
  export type Family = z.infer<typeof Family>;

  export const HttpType = zodSchemaHttpType();
  export type HttpType = z.infer<typeof HttpType>;

  export const JsonObject = zodSchemaJsonObject();
  export type JsonObject = z.infer<typeof JsonObject>;

  export const Link = zodSchemaLink();
  export type Link = z.infer<typeof Link>;

  export const ListString = zodSchemaListString();
  export type ListString = z.infer<typeof ListString>;

  export const Locale = zodSchemaLocale();
  export type Locale = z.infer<typeof Locale>;

  export const MapStringNewCookie = zodSchemaMapStringNewCookie();
  export type MapStringNewCookie = z.infer<typeof MapStringNewCookie>;

  export const MapStringString = zodSchemaMapStringString();
  export type MapStringString = z.infer<typeof MapStringString>;

  export const MediaType = zodSchemaMediaType();
  export type MediaType = z.infer<typeof MediaType>;

  export const MultivaluedMapStringObject = zodSchemaMultivaluedMapStringObject();
  export type MultivaluedMapStringObject = z.infer<
    typeof MultivaluedMapStringObject
  >;

  export const MultivaluedMapStringString = zodSchemaMultivaluedMapStringString();
  export type MultivaluedMapStringString = z.infer<
    typeof MultivaluedMapStringString
  >;

  export const NewCookie = zodSchemaNewCookie();
  export type NewCookie = z.infer<typeof NewCookie>;

  export const Notification = zodSchemaNotification();
  export type Notification = z.infer<typeof Notification>;

  export const NotificationHistory = zodSchemaNotificationHistory();
  export type NotificationHistory = z.infer<typeof NotificationHistory>;

  export const Response = zodSchemaResponse();
  export type Response = z.infer<typeof Response>;

  export const SetCharacter = zodSchemaSetCharacter();
  export type SetCharacter = z.infer<typeof SetCharacter>;

  export const SetEndpoint = zodSchemaSetEndpoint();
  export type SetEndpoint = z.infer<typeof SetEndpoint>;

  export const SetEventType = zodSchemaSetEventType();
  export type SetEventType = z.infer<typeof SetEventType>;

  export const SetLink = zodSchemaSetLink();
  export type SetLink = z.infer<typeof SetLink>;

  export const SetString = zodSchemaSetString();
  export type SetString = z.infer<typeof SetString>;

  export const StatusType = zodSchemaStatusType();
  export type StatusType = z.infer<typeof StatusType>;

  export const URI = zodSchemaURI();
  export type URI = z.infer<typeof URI>;

  export const UUID = zodSchemaUUID();
  export type UUID = z.infer<typeof UUID>;

  export const UriBuilder = zodSchemaUriBuilder();
  export type UriBuilder = z.infer<typeof UriBuilder>;

  export const WebhookAttributes = zodSchemaWebhookAttributes();
  export type WebhookAttributes = z.infer<typeof WebhookAttributes>;

  function zodSchemaApplication() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          description: z.string(),
          eventTypes: zodSchemaSetEventType().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: zodSchemaDate().optional().nullable()
      });
  }

  function zodSchemaAttributes() {
      return z.unknown();
  }

  function zodSchemaBasicAuthentication() {
      return z.object({
          password: z.string().optional().nullable(),
          username: z.string().optional().nullable()
      });
  }

  function zodSchemaDate() {
      return z.string();
  }

  function zodSchemaEmailAttributes() {
      return z.unknown();
  }

  function zodSchemaEndpoint() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          description: z.string(),
          enabled: z.boolean().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          properties: z
          .union([ zodSchemaWebhookAttributes(), zodSchemaEmailAttributes() ])
          .optional()
          .nullable(),
          type: z.intersection(
              zodSchemaEndpointType(),
              z.enum([ 'webhook', 'email', 'default' ])
          ),
          updated: zodSchemaDate().optional().nullable()
      });
  }

  function zodSchemaEndpointType() {
      return z.enum([ 'webhook', 'email', 'default' ]);
  }

  function zodSchemaEntityTag() {
      return z.object({
          value: z.string().optional().nullable(),
          weak: z.boolean().optional().nullable()
      });
  }

  function zodSchemaEventType() {
      return z.object({
          application: z
          .lazy(() => zodSchemaApplication())
          .optional()
          .nullable(),
          description: z.string(),
          endpoints: zodSchemaSetEndpoint().optional().nullable(),
          id: z.number().int().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaFamily() {
      return z.enum([
          'CLIENT_ERROR',
          'INFORMATIONAL',
          'OTHER',
          'REDIRECTION',
          'SERVER_ERROR',
          'SUCCESSFUL'
      ]);
  }

  function zodSchemaHttpType() {
      return z.enum([ 'GET', 'POST', 'PUT' ]);
  }

  function zodSchemaJsonObject() {
      return z.array(z.unknown());
  }

  function zodSchemaLink() {
      return z.object({
          params: zodSchemaMapStringString().optional().nullable(),
          rel: z.string().optional().nullable(),
          rels: zodSchemaListString().optional().nullable(),
          title: z.string().optional().nullable(),
          type: z.string().optional().nullable(),
          uri: zodSchemaURI().optional().nullable(),
          uriBuilder: zodSchemaUriBuilder().optional().nullable()
      });
  }

  function zodSchemaListString() {
      return z.array(z.string());
  }

  function zodSchemaLocale() {
      return z.object({
          country: z.string().optional().nullable(),
          displayCountry: z.string().optional().nullable(),
          displayLanguage: z.string().optional().nullable(),
          displayName: z.string().optional().nullable(),
          displayScript: z.string().optional().nullable(),
          displayVariant: z.string().optional().nullable(),
          extensionKeys: zodSchemaSetCharacter().optional().nullable(),
          iSO3Country: z.string().optional().nullable(),
          iSO3Language: z.string().optional().nullable(),
          language: z.string().optional().nullable(),
          script: z.string().optional().nullable(),
          unicodeLocaleAttributes: zodSchemaSetString().optional().nullable(),
          unicodeLocaleKeys: zodSchemaSetString().optional().nullable(),
          variant: z.string().optional().nullable()
      });
  }

  function zodSchemaMapStringNewCookie() {
      return z.record(zodSchemaNewCookie());
  }

  function zodSchemaMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaMediaType() {
      return z.object({
          parameters: zodSchemaMapStringString().optional().nullable(),
          subtype: z.string().optional().nullable(),
          type: z.string().optional().nullable(),
          wildcardSubtype: z.boolean().optional().nullable(),
          wildcardType: z.boolean().optional().nullable()
      });
  }

  function zodSchemaMultivaluedMapStringObject() {
      return z.record(z.unknown());
  }

  function zodSchemaMultivaluedMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaNewCookie() {
      return z.object({
          comment: z.string().optional().nullable(),
          domain: z.string().optional().nullable(),
          expiry: zodSchemaDate().optional().nullable(),
          httpOnly: z.boolean().optional().nullable(),
          maxAge: z.number().int().optional().nullable(),
          name: z.string().optional().nullable(),
          path: z.string().optional().nullable(),
          secure: z.boolean().optional().nullable(),
          value: z.string().optional().nullable(),
          version: z.number().int().optional().nullable()
      });
  }

  function zodSchemaNotification() {
      return z.object({
          endpoint: zodSchemaEndpoint().optional().nullable(),
          payload: z.unknown().optional().nullable(),
          tenant: z.string().optional().nullable()
      });
  }

  function zodSchemaNotificationHistory() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          details: zodSchemaJsonObject().optional().nullable(),
          endpointId: zodSchemaUUID().optional().nullable(),
          id: z.number().int().optional().nullable(),
          invocationResult: z.boolean().optional().nullable(),
          invocationTime: z.number().int().optional().nullable()
      });
  }

  function zodSchemaResponse() {
      return z.object({
          allowedMethods: zodSchemaSetString().optional().nullable(),
          cookies: zodSchemaMapStringNewCookie().optional().nullable(),
          date: zodSchemaDate().optional().nullable(),
          entity: z.unknown().optional().nullable(),
          entityTag: zodSchemaEntityTag().optional().nullable(),
          headers: zodSchemaMultivaluedMapStringObject().optional().nullable(),
          language: zodSchemaLocale().optional().nullable(),
          lastModified: zodSchemaDate().optional().nullable(),
          length: z.number().int().optional().nullable(),
          links: zodSchemaSetLink().optional().nullable(),
          location: zodSchemaURI().optional().nullable(),
          mediaType: zodSchemaMediaType().optional().nullable(),
          metadata: zodSchemaMultivaluedMapStringObject().optional().nullable(),
          status: z.number().int().optional().nullable(),
          statusInfo: zodSchemaStatusType().optional().nullable(),
          stringHeaders: zodSchemaMultivaluedMapStringString()
          .optional()
          .nullable()
      });
  }

  function zodSchemaSetCharacter() {
      return z.array(z.string());
  }

  function zodSchemaSetEndpoint() {
      return z.array(zodSchemaEndpoint());
  }

  function zodSchemaSetEventType() {
      return z.array(zodSchemaEventType());
  }

  function zodSchemaSetLink() {
      return z.array(zodSchemaLink());
  }

  function zodSchemaSetString() {
      return z.array(z.string());
  }

  function zodSchemaStatusType() {
      return z.object({
          family: zodSchemaFamily().optional().nullable(),
          reasonPhrase: z.string().optional().nullable(),
          statusCode: z.number().int().optional().nullable()
      });
  }

  function zodSchemaURI() {
      return z.string();
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchemaUriBuilder() {
      return z.unknown();
  }

  function zodSchemaWebhookAttributes() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean().optional().nullable(),
          method: z.intersection(
              zodSchemaHttpType(),
              z.enum([ 'GET', 'POST', 'PUT' ])
          ),
          secret_token: z.string().optional().nullable(),
          url: z.string()
      });
  }
}

export namespace Operations {
  // GET /notifications/defaults
  export namespace NotificationServiceGetEndpointsForDefaults {
    const Response200 = z.array(Schemas.Endpoint);
    type Response200 = z.infer<typeof Response200>;
    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/defaults';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // PUT /notifications/defaults/{endpointId}
  export namespace NotificationServiceAddEndpointToDefaults {
    export interface Params {
      endpointId: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Response', 200, Schemas.Response>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/defaults/{endpointId}'.replace(
            '{endpointId}',
            params.endpointId.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.Response, 'Response', 200) ]
        })
        .build();
    };
  }
  // DELETE /notifications/defaults/{endpointId}
  export namespace NotificationServiceDeleteEndpointFromDefaults {
    export interface Params {
      endpointId: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Response', 200, Schemas.Response>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/defaults/{endpointId}'.replace(
            '{endpointId}',
            params.endpointId.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.Response, 'Response', 200) ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes
  export namespace NotificationServiceGetEventTypes {
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const PageNumber = z.number().int();
    type PageNumber = z.infer<typeof PageNumber>;
    const SortBy = z.string();
    type SortBy = z.infer<typeof SortBy>;
    const Response200 = z.array(Schemas.EventType);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      limit?: Limit;
      offset?: Offset;
      pageNumber?: PageNumber;
      sortBy?: SortBy;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/eventTypes';
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes/{eventTypeId}
  export namespace NotificationServiceGetLinkedEndpoints {
    const EventTypeId = z.number().int();
    type EventTypeId = z.infer<typeof EventTypeId>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const PageNumber = z.number().int();
    type PageNumber = z.infer<typeof PageNumber>;
    const SortBy = z.string();
    type SortBy = z.infer<typeof SortBy>;
    const Response200 = z.array(Schemas.Endpoint);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      eventTypeId: EventTypeId;
      limit?: Limit;
      offset?: Offset;
      pageNumber?: PageNumber;
      sortBy?: SortBy;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}'.replace(
            '{eventTypeId}',
            params.eventTypeId.toString()
        );
        const query = {} as Record<string, any>;
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // PUT /notifications/eventTypes/{eventTypeId}/{endpointId}
  export namespace NotificationServiceLinkEndpointToEventType {
    const EventTypeId = z.number().int();
    type EventTypeId = z.infer<typeof EventTypeId>;
    const Response200 = z.string();
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      endpointId: Schemas.UUID;
      eventTypeId: EventTypeId;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/{endpointId}'
        .replace('{endpointId}', params.endpointId.toString())
        .replace('{eventTypeId}', params.eventTypeId.toString());
        const query = {} as Record<string, any>;
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // DELETE /notifications/eventTypes/{eventTypeId}/{endpointId}
  export namespace NotificationServiceUnlinkEndpointFromEventType {
    const EventTypeId = z.number().int();
    type EventTypeId = z.infer<typeof EventTypeId>;
    export interface Params {
      endpointId: Schemas.UUID;
      eventTypeId: EventTypeId;
    }

    export type Payload =
      | ValidatedResponse<'Response', 200, Schemas.Response>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/{endpointId}'
        .replace('{endpointId}', params.endpointId.toString())
        .replace('{eventTypeId}', params.eventTypeId.toString());
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.Response, 'Response', 200) ]
        })
        .build();
    };
  }
  // GET /notifications/updates
  export namespace NotificationServiceGetNotificationUpdates {
    const Response200 = z.array(Schemas.Notification);
    type Response200 = z.infer<typeof Response200>;
    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/updates';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // DELETE /notifications/{id}
  export namespace NotificationServiceMarkRead {
    const Body = z.number().int();
    type Body = z.infer<typeof Body>;
    export interface Params {
      body: Body;
    }

    export type Payload =
      | ValidatedResponse<'Response', 200, Schemas.Response>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/notifications/v1.0/notifications/{id}';
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Schemas.Response, 'Response', 200) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/notifications-openapi.json execute input file accepts path 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidateRule } from 'openapi2typescript';
import { actionBuilder } from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Application = zodSchemaApplication();

  export const Attributes = zodSchemaAttributes();

  export const BasicAuthentication = zodSchemaBasicAuthentication();

  export const Date = zodSchemaDate();

  export const EmailAttributes = zodSchemaEmailAttributes();

  export const Endpoint = zodSchemaEndpoint();

  export const EndpointType = zodSchemaEndpointType();

  export const EntityTag = zodSchemaEntityTag();

  export const EventType = zodSchemaEventType();

  export const Family = zodSchemaFamily();

  export const HttpType = zodSchemaHttpType();

  export const JsonObject = zodSchemaJsonObject();

  export const Link = zodSchemaLink();

  export const ListString = zodSchemaListString();

  export const Locale = zodSchemaLocale();

  export const MapStringNewCookie = zodSchemaMapStringNewCookie();

  export const MapStringString = zodSchemaMapStringString();

  export const MediaType = zodSchemaMediaType();

  export const MultivaluedMapStringObject = zodSchemaMultivaluedMapStringObject();

  export const MultivaluedMapStringString = zodSchemaMultivaluedMapStringString();

  export const NewCookie = zodSchemaNewCookie();

  export const Notification = zodSchemaNotification();

  export const NotificationHistory = zodSchemaNotificationHistory();

  export const Response = zodSchemaResponse();

  export const SetCharacter = zodSchemaSetCharacter();

  export const SetEndpoint = zodSchemaSetEndpoint();

  export const SetEventType = zodSchemaSetEventType();

  export const SetLink = zodSchemaSetLink();

  export const SetString = zodSchemaSetString();

  export const StatusType = zodSchemaStatusType();

  export const URI = zodSchemaURI();

  export const UUID = zodSchemaUUID();

  export const UriBuilder = zodSchemaUriBuilder();

  export const WebhookAttributes = zodSchemaWebhookAttributes();

  function zodSchemaApplication() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          description: z.string(),
          eventTypes: zodSchemaSetEventType().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          updated: zodSchemaDate().optional().nullable()
      });
  }

  function zodSchemaAttributes() {
      return z.unknown();
  }

  function zodSchemaBasicAuthentication() {
      return z.object({
          password: z.string().optional().nullable(),
          username: z.string().optional().nullable()
      });
  }

  function zodSchemaDate() {
      return z.string();
  }

  function zodSchemaEmailAttributes() {
      return z.unknown();
  }

  function zodSchemaEndpoint() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          description: z.string(),
          enabled: z.boolean().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          name: z.string(),
          properties: z
          .union([ zodSchemaWebhookAttributes(), zodSchemaEmailAttributes() ])
          .optional()
          .nullable(),
          type: z.intersection(
              zodSchemaEndpointType(),
              z.enum([ 'webhook', 'email', 'default' ])
          ),
          updated: zodSchemaDate().optional().nullable()
      });
  }

  function zodSchemaEndpointType() {
      return z.enum([ 'webhook', 'email', 'default' ]);
  }

  function zodSchemaEntityTag() {
      return z.object({
          value: z.string().optional().nullable(),
          weak: z.boolean().optional().nullable()
      });
  }

  function zodSchemaEventType() {
      return z.object({
          application: z
          .lazy(() => zodSchemaApplication())
          .optional()
          .nullable(),
          description: z.string(),
          endpoints: zodSchemaSetEndpoint().optional().nullable(),
          id: z.number().int().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaFamily() {
      return z.enum([
          'CLIENT_ERROR',
          'INFORMATIONAL',
          'OTHER',
          'REDIRECTION',
          'SERVER_ERROR',
          'SUCCESSFUL'
      ]);
  }

  function zodSchemaHttpType() {
      return z.enum([ 'GET', 'POST', 'PUT' ]);
  }

  function zodSchemaJsonObject() {
      return z.array(z.unknown());
  }

  function zodSchemaLink() {
      return z.object({
          params: zodSchemaMapStringString().optional().nullable(),
          rel: z.string().optional().nullable(),
          rels: zodSchemaListString().optional().nullable(),
          title: z.string().optional().nullable(),
          type: z.string().optional().nullable(),
          uri: zodSchemaURI().optional().nullable(),
          uriBuilder: zodSchemaUriBuilder().optional().nullable()
      });
  }

  function zodSchemaListString() {
      return z.array(z.string());
  }

  function zodSchemaLocale() {
      return z.object({
          country: z.string().optional().nullable(),
          displayCountry: z.string().optional().nullable(),
          displayLanguage: z.string().optional().nullable(),
          displayName: z.string().optional().nullable(),
          displayScript: z.string().optional().nullable(),
          displayVariant: z.string().optional().nullable(),
          extensionKeys: zodSchemaSetCharacter().optional().nullable(),
          iSO3Country: z.string().optional().nullable(),
          iSO3Language: z.string().optional().nullable(),
          language: z.string().optional().nullable(),
          script: z.string().optional().nullable(),
          unicodeLocaleAttributes: zodSchemaSetString().optional().nullable(),
          unicodeLocaleKeys: zodSchemaSetString().optional().nullable(),
          variant: z.string().optional().nullable()
      });
  }

  function zodSchemaMapStringNewCookie() {
      return z.record(zodSchemaNewCookie());
  }

  function zodSchemaMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaMediaType() {
      return z.object({
          parameters: zodSchemaMapStringString().optional().nullable(),
          subtype: z.string().optional().nullable(),
          type: z.string().optional().nullable(),
          wildcardSubtype: z.boolean().optional().nullable(),
          wildcardType: z.boolean().optional().nullable()
      });
  }

  function zodSchemaMultivaluedMapStringObject() {
      return z.record(z.unknown());
  }

  function zodSchemaMultivaluedMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaNewCookie() {
      return z.object({
          comment: z.string().optional().nullable(),
          domain: z.string().optional().nullable(),
          expiry: zodSchemaDate().optional().nullable(),
          httpOnly: z.boolean().optional().nullable(),
          maxAge: z.number().int().optional().nullable(),
          name: z.string().optional().nullable(),
          path: z.string().optional().nullable(),
          secure: z.boolean().optional().nullable(),
          value: z.string().optional().nullable(),
          version: z.number().int().optional().nullable()
      });
  }

  function zodSchemaNotification() {
      return z.object({
          endpoint: zodSchemaEndpoint().optional().nullable(),
          payload: z.unknown().optional().nullable(),
          tenant: z.string().optional().nullable()
      });
  }

  function zodSchemaNotificationHistory() {
      return z.object({
          created: zodSchemaDate().optional().nullable(),
          details: zodSchemaJsonObject().optional().nullable(),
          endpointId: zodSchemaUUID().optional().nullable(),
          id: z.number().int().optional().nullable(),
          invocationResult: z.boolean().optional().nullable(),
          invocationTime: z.number().int().optional().nullable()
      });
  }

  function zodSchemaResponse() {
      return z.object({
          allowedMethods: zodSchemaSetString().optional().nullable(),
          cookies: zodSchemaMapStringNewCookie().optional().nullable(),
          date: zodSchemaDate().optional().nullable(),
          entity: z.unknown().optional().nullable(),
          entityTag: zodSchemaEntityTag().optional().nullable(),
          headers: zodSchemaMultivaluedMapStringObject().optional().nullable(),
          language: zodSchemaLocale().optional().nullable(),
          lastModified: zodSchemaDate().optional().nullable(),
          length: z.number().int().optional().nullable(),
          links: zodSchemaSetLink().optional().nullable(),
          location: zodSchemaURI().optional().nullable(),
          mediaType: zodSchemaMediaType().optional().nullable(),
          metadata: zodSchemaMultivaluedMapStringObject().optional().nullable(),
          status: z.number().int().optional().nullable(),
          statusInfo: zodSchemaStatusType().optional().nullable(),
          stringHeaders: zodSchemaMultivaluedMapStringString()
          .optional()
          .nullable()
      });
  }

  function zodSchemaSetCharacter() {
      return z.array(z.string());
  }

  function zodSchemaSetEndpoint() {
      return z.array(zodSchemaEndpoint());
  }

  function zodSchemaSetEventType() {
      return z.array(zodSchemaEventType());
  }

  function zodSchemaSetLink() {
      return z.array(zodSchemaLink());
  }

  function zodSchemaSetString() {
      return z.array(z.string());
  }

  function zodSchemaStatusType() {
      return z.object({
          family: zodSchemaFamily().optional().nullable(),
          reasonPhrase: z.string().optional().nullable(),
          statusCode: z.number().int().optional().nullable()
      });
  }

  function zodSchemaURI() {
      return z.string();
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchemaUriBuilder() {
      return z.unknown();
  }

  function zodSchemaWebhookAttributes() {
      return z.object({
          basic_authentication: zodSchemaBasicAuthentication()
          .optional()
          .nullable(),
          disable_ssl_verification: z.boolean().optional().nullable(),
          method: z.intersection(
              zodSchemaHttpType(),
              z.enum([ 'GET', 'POST', 'PUT' ])
          ),
          secret_token: z.string().optional().nullable(),
          url: z.string()
      });
  }
}

export namespace Operations {
  // GET /notifications/defaults
  export namespace NotificationServiceGetEndpointsForDefaults {
    const Response200 = z.array(Schemas.Endpoint);
    export const actionCreator = () => {
        const path = '/api/notifications/v1.0/notifications/defaults';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // PUT /notifications/defaults/{endpointId}
  export namespace NotificationServiceAddEndpointToDefaults {
    /*
 Params
'endpointId':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/defaults/{endpointId}'.replace(
            '{endpointId}',
            params.endpointId.toString()
        );
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.Response, 'Response', 200) ]
        })
        .build();
    };
  }
  // DELETE /notifications/defaults/{endpointId}
  export namespace NotificationServiceDeleteEndpointFromDefaults {
    /*
 Params
'endpointId':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/defaults/{endpointId}'.replace(
            '{endpointId}',
            params.endpointId.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.Response, 'Response', 200) ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes
  export namespace NotificationServiceGetEventTypes {
    const Limit = z.number().int();
    const Offset = z.number().int();
    const PageNumber = z.number().int();
    const SortBy = z.string();
    const Response200 = z.array(Schemas.EventType);
    /*
 Params
'limit'?:Limit,
'offset'?:Offset,
'pageNumber'?:PageNumber,
'sortBy'?:SortBy
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/eventTypes';
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // GET /notifications/eventTypes/{eventTypeId}
  export namespace NotificationServiceGetLinkedEndpoints {
    const EventTypeId = z.number().int();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const PageNumber = z.number().int();
    const SortBy = z.string();
    const Response200 = z.array(Schemas.Endpoint);
    /*
 Params
'eventTypeId':EventTypeId,
'limit'?:Limit,
'offset'?:Offset,
'pageNumber'?:PageNumber,
'sortBy'?:SortBy
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}'.replace(
            '{eventTypeId}',
            params.eventTypeId.toString()
        );
        const query = {};
        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.pageNumber !== undefined) {
            query.pageNumber = params.pageNumber;
        }

        if (params.sortBy !== undefined) {
            query.sort_by = params.sortBy;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // PUT /notifications/eventTypes/{eventTypeId}/{endpointId}
  export namespace NotificationServiceLinkEndpointToEventType {
    const EventTypeId = z.number().int();
    const Response200 = z.string();
    /*
 Params
'endpointId':Schemas.UUID,
'eventTypeId':EventTypeId
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/{endpointId}'
        .replace('{endpointId}', params.endpointId.toString())
        .replace('{eventTypeId}', params.eventTypeId.toString());
        const query = {};
        return actionBuilder('PUT', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // DELETE /notifications/eventTypes/{eventTypeId}/{endpointId}
  export namespace NotificationServiceUnlinkEndpointFromEventType {
    const EventTypeId = z.number().int();
    /*
 Params
'endpointId':Schemas.UUID,
'eventTypeId':EventTypeId
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/eventTypes/{eventTypeId}/{endpointId}'
        .replace('{endpointId}', params.endpointId.toString())
        .replace('{eventTypeId}', params.eventTypeId.toString());
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.Response, 'Response', 200) ]
        })
        .build();
    };
  }
  // GET /notifications/updates
  export namespace NotificationServiceGetNotificationUpdates {
    const Response200 = z.array(Schemas.Notification);
    export const actionCreator = () => {
        const path = '/api/notifications/v1.0/notifications/updates';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // DELETE /notifications/{id}
  export namespace NotificationServiceMarkRead {
    const Body = z.number().int();
    /*
 Params
body: Body
*/
    export const actionCreator = (params) => {
        const path = '/api/notifications/v1.0/notifications/{id}';
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Schemas.Response, 'Response', 200) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/policies-openapi.json execute accepts urls 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidatedResponse } from 'openapi2typescript';
import { Action } from 'react-fetching-library';
import { ValidateRule } from 'openapi2typescript';
import {
    actionBuilder,
    ActionValidatableConfig
} from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Fact = zodSchemaFact();
  export type Fact = z.infer<typeof Fact>;

  export const FactType = zodSchemaFactType();
  export type FactType = z.infer<typeof FactType>;

  export const HistoryItem = zodSchemaHistoryItem();
  export type HistoryItem = z.infer<typeof HistoryItem>;

  export const List = zodSchemaList();
  export type List = z.infer<typeof List>;

  export const ListHistoryItem = zodSchemaListHistoryItem();
  export type ListHistoryItem = z.infer<typeof ListHistoryItem>;

  export const ListPolicy = zodSchemaListPolicy();
  export type ListPolicy = z.infer<typeof ListPolicy>;

  export const ListUUID = zodSchemaListUUID();
  export type ListUUID = z.infer<typeof ListUUID>;

  export const MapStringString = zodSchemaMapStringString();
  export type MapStringString = z.infer<typeof MapStringString>;

  export const Meta = zodSchemaMeta();
  export type Meta = z.infer<typeof Meta>;

  export const PagedResponseOfHistoryItem = zodSchemaPagedResponseOfHistoryItem();
  export type PagedResponseOfHistoryItem = z.infer<
    typeof PagedResponseOfHistoryItem
  >;

  export const PagedResponseOfPolicy = zodSchemaPagedResponseOfPolicy();
  export type PagedResponseOfPolicy = z.infer<typeof PagedResponseOfPolicy>;

  export const Policy = zodSchemaPolicy();
  export type Policy = z.infer<typeof Policy>;

  export const UUID = zodSchemaUUID();
  export type UUID = z.infer<typeof UUID>;

  export const __Empty = zodSchema__Empty();
  export type __Empty = z.infer<typeof __Empty>;

  function zodSchemaFact() {
      return z.object({
          id: z.number().int().optional().nullable(),
          name: z.string().optional().nullable(),
          type: zodSchemaFactType().optional().nullable()
      });
  }

  function zodSchemaFactType() {
      return z.enum([ 'BOOLEAN', 'INT', 'LIST', 'STRING' ]);
  }

  function zodSchemaHistoryItem() {
      return z.object({
          ctime: z.number().int().optional().nullable(),
          hostName: z.string().optional().nullable(),
          id: z.string().optional().nullable()
      });
  }

  function zodSchemaList() {
      return z.array(z.unknown());
  }

  function zodSchemaListHistoryItem() {
      return z.array(zodSchemaHistoryItem());
  }

  function zodSchemaListPolicy() {
      return z.array(zodSchemaPolicy());
  }

  function zodSchemaListUUID() {
      return z.array(z.string());
  }

  function zodSchemaMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaMeta() {
      return z.object({
          count: z.number().int().optional().nullable()
      });
  }

  function zodSchemaPagedResponseOfHistoryItem() {
      return z.object({
          data: zodSchemaListHistoryItem().optional().nullable(),
          links: zodSchemaMapStringString().optional().nullable(),
          meta: zodSchemaMeta().optional().nullable()
      });
  }

  function zodSchemaPagedResponseOfPolicy() {
      return z.object({
          data: zodSchemaListPolicy().optional().nullable(),
          links: zodSchemaMapStringString().optional().nullable(),
          meta: zodSchemaMeta().optional().nullable()
      });
  }

  function zodSchemaPolicy() {
      return z.object({
          actions: z.string().optional().nullable(),
          conditions: z.string(),
          ctime: z.string().optional().nullable(),
          description: z.string().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          isEnabled: z.boolean().optional().nullable(),
          lastTriggered: z.number().int().optional().nullable(),
          mtime: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // GET /
  // Just a filler to have a defined return code for the base path
  export namespace Get {
    export type Payload =
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/api/policies/v1.0/';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.__Empty, '__Empty', 404) ]
        })
        .build();
    };
  }
  // GET /facts
  // Retrieve a list of fact (keys) along with their data types
  export namespace GetFacts {
    const Response200 = z.array(Schemas.Fact);
    type Response200 = z.infer<typeof Response200>;
    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/api/policies/v1.0/facts';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // GET /policies
  // Return all policies for a given account
  export namespace GetPolicies {
    const FilterOpDescription = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    type FilterOpDescription = z.infer<typeof FilterOpDescription>;
    const FilterOpName = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    type FilterOpName = z.infer<typeof FilterOpName>;
    const FilterDescription = z.string();
    type FilterDescription = z.infer<typeof FilterDescription>;
    const FilterIsEnabled = z.enum([ 'true', 'false' ]);
    type FilterIsEnabled = z.infer<typeof FilterIsEnabled>;
    const FilterName = z.string();
    type FilterName = z.infer<typeof FilterName>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const SortColumn = z.enum([ 'name', 'description', 'is_enabled', 'mtime' ]);
    type SortColumn = z.infer<typeof SortColumn>;
    const SortDirection = z.enum([ 'asc', 'desc' ]);
    type SortDirection = z.infer<typeof SortDirection>;
    export interface Params {
      filterOpDescription?: FilterOpDescription;
      filterOpName?: FilterOpName;
      filterDescription?: FilterDescription;
      filterIsEnabled?: FilterIsEnabled;
      filterName?: FilterName;
      limit?: Limit;
      offset?: Offset;
      sortColumn?: SortColumn;
      sortDirection?: SortDirection;
    }

    export type Payload =
      | ValidatedResponse<
          'PagedResponseOfPolicy',
          200,
          Schemas.PagedResponseOfPolicy
        >
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies';
        const query = {} as Record<string, any>;
        if (params.filterOpDescription !== undefined) {
            query['filter:op[description]'] = params.filterOpDescription;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterDescription !== undefined) {
            query['filter[description]'] = params.filterDescription;
        }

        if (params.filterIsEnabled !== undefined) {
            query['filter[is_enabled]'] = params.filterIsEnabled;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortColumn !== undefined) {
            query.sortColumn = params.sortColumn;
        }

        if (params.sortDirection !== undefined) {
            query.sortDirection = params.sortDirection;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PagedResponseOfPolicy,
                    'PagedResponseOfPolicy',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // POST /policies
  // Validate (and possibly persist) a passed policy for the given account
  export namespace PostPolicies {
    const AlsoStore = z.boolean();
    type AlsoStore = z.infer<typeof AlsoStore>;
    const Response400 = z.object({
        msg: z.string().optional().nullable()
    });
    type Response400 = z.infer<typeof Response400>;
    const Response409 = z.object({
        msg: z.string().optional().nullable()
    });
    type Response409 = z.infer<typeof Response409>;
    export interface Params {
      alsoStore?: AlsoStore;
      body: Schemas.Policy;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'Policy', 201, Schemas.Policy>
      | ValidatedResponse<'Response400', 400, Response400>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'Response409', 409, Response409>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies';
        const query = {} as Record<string, any>;
        if (params.alsoStore !== undefined) {
            query.alsoStore = params.alsoStore;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.Policy, 'Policy', 201),
                new ValidateRule(Response400, 'Response400', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Response409, 'Response409', 409),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/ids
  // Return all policy ids for a given account after applying the filters
  export namespace GetPoliciesIds {
    const FilterOpDescription = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    type FilterOpDescription = z.infer<typeof FilterOpDescription>;
    const FilterOpName = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    type FilterOpName = z.infer<typeof FilterOpName>;
    const FilterDescription = z.string();
    type FilterDescription = z.infer<typeof FilterDescription>;
    const FilterIsEnabled = z.enum([ 'true', 'false' ]);
    type FilterIsEnabled = z.infer<typeof FilterIsEnabled>;
    const FilterName = z.string();
    type FilterName = z.infer<typeof FilterName>;
    export interface Params {
      filterOpDescription?: FilterOpDescription;
      filterOpName?: FilterOpName;
      filterDescription?: FilterDescription;
      filterIsEnabled?: FilterIsEnabled;
      filterName?: FilterName;
    }

    export type Payload =
      | ValidatedResponse<'List', 200, Schemas.List>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/ids';
        const query = {} as Record<string, any>;
        if (params.filterOpDescription !== undefined) {
            query['filter:op[description]'] = params.filterOpDescription;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterDescription !== undefined) {
            query['filter[description]'] = params.filterDescription;
        }

        if (params.filterIsEnabled !== undefined) {
            query['filter[is_enabled]'] = params.filterIsEnabled;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.List, 'List', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/ids
  // Delete policies for a customer by the ids passed in the body. Result will be a list of deleted UUIDs
  export namespace DeletePoliciesIds {
    const Response200 = z.array(Schemas.UUID);
    type Response200 = z.infer<typeof Response200>;
    export interface Params {
      body: Schemas.ListUUID;
    }

    export type Payload =
      | ValidatedResponse<'Response200', 200, Response200>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/ids';
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'Response200', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /policies/ids/enabled
  // Enable/disable policies identified by list of uuid in body
  export namespace PostPoliciesIdsEnabled {
    const Enabled = z.boolean();
    type Enabled = z.infer<typeof Enabled>;
    export interface Params {
      enabled?: Enabled;
      body: Schemas.ListUUID;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/ids/enabled';
        const query = {} as Record<string, any>;
        if (params.enabled !== undefined) {
            query.enabled = params.enabled;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /policies/validate
  // Validates a Policy condition
  export namespace PostPoliciesValidate {
    export interface Params {
      body: Schemas.Policy;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/validate';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // POST /policies/validate-name
  // Validates the Policy.name and verifies if it is unique.
  export namespace PostPoliciesValidateName {
    const Body = z.string();
    type Body = z.infer<typeof Body>;
    export interface Params {
      id?: Schemas.UUID;
      body: Body;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 409, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/validate-name';
        const query = {} as Record<string, any>;
        if (params.id !== undefined) {
            query.id = params.id;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 409),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{id}
  // Retrieve a single policy for a customer by its id
  export namespace GetPoliciesById {
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'Policy', 200, Schemas.Policy>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.Policy, 'Policy', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/{id}
  // Delete a single policy for a customer by its id
  export namespace DeletePoliciesById {
    export interface Params {
      id: Schemas.UUID;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // POST /policies/{id}/enabled
  // Enable/disable a policy
  export namespace PostPoliciesByIdEnabled {
    const Enabled = z.boolean();
    type Enabled = z.infer<typeof Enabled>;
    export interface Params {
      id: Schemas.UUID;
      enabled?: Enabled;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{id}/enabled'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        if (params.enabled !== undefined) {
            query.enabled = params.enabled;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{id}/history/trigger
  // Retrieve the trigger history of a single policy
  export namespace GetPoliciesByIdHistoryTrigger {
    const FilterOpId = z.enum([ 'equal', 'not_equal', 'like' ]);
    type FilterOpId = z.infer<typeof FilterOpId>;
    const FilterOpName = z.enum([ 'equal', 'like', 'not_equal' ]);
    type FilterOpName = z.infer<typeof FilterOpName>;
    const FilterId = z.string();
    type FilterId = z.infer<typeof FilterId>;
    const FilterName = z.string();
    type FilterName = z.infer<typeof FilterName>;
    const Limit = z.number().int();
    type Limit = z.infer<typeof Limit>;
    const Offset = z.number().int();
    type Offset = z.infer<typeof Offset>;
    const SortColumn = z.enum([ 'hostName', 'id', 'ctime' ]);
    type SortColumn = z.infer<typeof SortColumn>;
    const SortDirection = z.enum([ 'asc', 'desc' ]);
    type SortDirection = z.infer<typeof SortDirection>;
    export interface Params {
      id: Schemas.UUID;
      filterOpId?: FilterOpId;
      filterOpName?: FilterOpName;
      filterId?: FilterId;
      filterName?: FilterName;
      limit?: Limit;
      offset?: Offset;
      sortColumn?: SortColumn;
      sortDirection?: SortDirection;
    }

    export type Payload =
      | ValidatedResponse<
          'PagedResponseOfHistoryItem',
          200,
          Schemas.PagedResponseOfHistoryItem
        >
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 500, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{id}/history/trigger'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {} as Record<string, any>;
        if (params.filterOpId !== undefined) {
            query['filter:op[id]'] = params.filterOpId;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterId !== undefined) {
            query['filter[id]'] = params.filterId;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortColumn !== undefined) {
            query.sortColumn = params.sortColumn;
        }

        if (params.sortDirection !== undefined) {
            query.sortDirection = params.sortDirection;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PagedResponseOfHistoryItem,
                    'PagedResponseOfHistoryItem',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // PUT /policies/{policyId}
  // Update a single policy for a customer by its id
  export namespace PutPoliciesByPolicyId {
    const Dry = z.boolean();
    type Dry = z.infer<typeof Dry>;
    const Response409 = z.object({
        msg: z.string().optional().nullable()
    });
    type Response409 = z.infer<typeof Response409>;
    export interface Params {
      policyId: Schemas.UUID;
      dry?: Dry;
      body: Schemas.Policy;
    }

    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 400, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 403, Schemas.__Empty>
      | ValidatedResponse<'__Empty', 404, Schemas.__Empty>
      | ValidatedResponse<'Response409', 409, Response409>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/api/policies/v1.0/policies/{policyId}'.replace(
            '{policyId}',
            params.policyId.toString()
        );
        const query = {} as Record<string, any>;
        if (params.dry !== undefined) {
            query.dry = params.dry;
        }

        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Response409, 'Response409', 409)
            ]
        })
        .build();
    };
  }
  // GET /status
  export namespace GetStatus {
    export type Payload =
      | ValidatedResponse<'__Empty', 200, Schemas.__Empty>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/api/policies/v1.0/status';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.__Empty, '__Empty', 200) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/policies-openapi.json execute input file accepts path 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidateRule } from 'openapi2typescript';
import { actionBuilder } from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Fact = zodSchemaFact();

  export const FactType = zodSchemaFactType();

  export const HistoryItem = zodSchemaHistoryItem();

  export const List = zodSchemaList();

  export const ListHistoryItem = zodSchemaListHistoryItem();

  export const ListPolicy = zodSchemaListPolicy();

  export const ListUUID = zodSchemaListUUID();

  export const MapStringString = zodSchemaMapStringString();

  export const Meta = zodSchemaMeta();

  export const PagedResponseOfHistoryItem = zodSchemaPagedResponseOfHistoryItem();

  export const PagedResponseOfPolicy = zodSchemaPagedResponseOfPolicy();

  export const Policy = zodSchemaPolicy();

  export const UUID = zodSchemaUUID();

  export const __Empty = zodSchema__Empty();

  function zodSchemaFact() {
      return z.object({
          id: z.number().int().optional().nullable(),
          name: z.string().optional().nullable(),
          type: zodSchemaFactType().optional().nullable()
      });
  }

  function zodSchemaFactType() {
      return z.enum([ 'BOOLEAN', 'INT', 'LIST', 'STRING' ]);
  }

  function zodSchemaHistoryItem() {
      return z.object({
          ctime: z.number().int().optional().nullable(),
          hostName: z.string().optional().nullable(),
          id: z.string().optional().nullable()
      });
  }

  function zodSchemaList() {
      return z.array(z.unknown());
  }

  function zodSchemaListHistoryItem() {
      return z.array(zodSchemaHistoryItem());
  }

  function zodSchemaListPolicy() {
      return z.array(zodSchemaPolicy());
  }

  function zodSchemaListUUID() {
      return z.array(z.string());
  }

  function zodSchemaMapStringString() {
      return z.record(z.string());
  }

  function zodSchemaMeta() {
      return z.object({
          count: z.number().int().optional().nullable()
      });
  }

  function zodSchemaPagedResponseOfHistoryItem() {
      return z.object({
          data: zodSchemaListHistoryItem().optional().nullable(),
          links: zodSchemaMapStringString().optional().nullable(),
          meta: zodSchemaMeta().optional().nullable()
      });
  }

  function zodSchemaPagedResponseOfPolicy() {
      return z.object({
          data: zodSchemaListPolicy().optional().nullable(),
          links: zodSchemaMapStringString().optional().nullable(),
          meta: zodSchemaMeta().optional().nullable()
      });
  }

  function zodSchemaPolicy() {
      return z.object({
          actions: z.string().optional().nullable(),
          conditions: z.string(),
          ctime: z.string().optional().nullable(),
          description: z.string().optional().nullable(),
          id: zodSchemaUUID().optional().nullable(),
          isEnabled: z.boolean().optional().nullable(),
          lastTriggered: z.number().int().optional().nullable(),
          mtime: z.string().optional().nullable(),
          name: z.string()
      });
  }

  function zodSchemaUUID() {
      return z.string();
  }

  function zodSchema__Empty() {
      return z.string().max(0).optional();
  }
}

export namespace Operations {
  // GET /
  // Just a filler to have a defined return code for the base path
  export namespace Get {
    export const actionCreator = () => {
        const path = '/api/policies/v1.0/';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.__Empty, '__Empty', 404) ]
        })
        .build();
    };
  }
  // GET /facts
  // Retrieve a list of fact (keys) along with their data types
  export namespace GetFacts {
    const Response200 = z.array(Schemas.Fact);
    export const actionCreator = () => {
        const path = '/api/policies/v1.0/facts';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Response200, 'Response200', 200) ]
        })
        .build();
    };
  }
  // GET /policies
  // Return all policies for a given account
  export namespace GetPolicies {
    const FilterOpDescription = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    const FilterOpName = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    const FilterDescription = z.string();
    const FilterIsEnabled = z.enum([ 'true', 'false' ]);
    const FilterName = z.string();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const SortColumn = z.enum([ 'name', 'description', 'is_enabled', 'mtime' ]);
    const SortDirection = z.enum([ 'asc', 'desc' ]);
    /*
 Params
'filterOpDescription'?:FilterOpDescription,
'filterOpName'?:FilterOpName,
'filterDescription'?:FilterDescription,
'filterIsEnabled'?:FilterIsEnabled,
'filterName'?:FilterName,
'limit'?:Limit,
'offset'?:Offset,
'sortColumn'?:SortColumn,
'sortDirection'?:SortDirection
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies';
        const query = {};
        if (params.filterOpDescription !== undefined) {
            query['filter:op[description]'] = params.filterOpDescription;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterDescription !== undefined) {
            query['filter[description]'] = params.filterDescription;
        }

        if (params.filterIsEnabled !== undefined) {
            query['filter[is_enabled]'] = params.filterIsEnabled;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortColumn !== undefined) {
            query.sortColumn = params.sortColumn;
        }

        if (params.sortDirection !== undefined) {
            query.sortDirection = params.sortDirection;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PagedResponseOfPolicy,
                    'PagedResponseOfPolicy',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // POST /policies
  // Validate (and possibly persist) a passed policy for the given account
  export namespace PostPolicies {
    const AlsoStore = z.boolean();
    const Response400 = z.object({
        msg: z.string().optional().nullable()
    });
    const Response409 = z.object({
        msg: z.string().optional().nullable()
    });
    /*
 Params
'alsoStore'?:AlsoStore,
body: Schemas.Policy
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies';
        const query = {};
        if (params.alsoStore !== undefined) {
            query.alsoStore = params.alsoStore;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.Policy, 'Policy', 201),
                new ValidateRule(Response400, 'Response400', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Response409, 'Response409', 409),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/ids
  // Return all policy ids for a given account after applying the filters
  export namespace GetPoliciesIds {
    const FilterOpDescription = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    const FilterOpName = z.enum([ 'equal', 'like', 'ilike', 'not_equal' ]);
    const FilterDescription = z.string();
    const FilterIsEnabled = z.enum([ 'true', 'false' ]);
    const FilterName = z.string();
    /*
 Params
'filterOpDescription'?:FilterOpDescription,
'filterOpName'?:FilterOpName,
'filterDescription'?:FilterDescription,
'filterIsEnabled'?:FilterIsEnabled,
'filterName'?:FilterName
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/ids';
        const query = {};
        if (params.filterOpDescription !== undefined) {
            query['filter:op[description]'] = params.filterOpDescription;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterDescription !== undefined) {
            query['filter[description]'] = params.filterDescription;
        }

        if (params.filterIsEnabled !== undefined) {
            query['filter[is_enabled]'] = params.filterIsEnabled;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.List, 'List', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/ids
  // Delete policies for a customer by the ids passed in the body. Result will be a list of deleted UUIDs
  export namespace DeletePoliciesIds {
    const Response200 = z.array(Schemas.UUID);
    /*
 Params
body: Schemas.ListUUID
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/ids';
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Response200, 'Response200', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /policies/ids/enabled
  // Enable/disable policies identified by list of uuid in body
  export namespace PostPoliciesIdsEnabled {
    const Enabled = z.boolean();
    /*
 Params
'enabled'?:Enabled,
body: Schemas.ListUUID
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/ids/enabled';
        const query = {};
        if (params.enabled !== undefined) {
            query.enabled = params.enabled;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403)
            ]
        })
        .build();
    };
  }
  // POST /policies/validate
  // Validates a Policy condition
  export namespace PostPoliciesValidate {
    /*
 Params
body: Schemas.Policy
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/validate';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // POST /policies/validate-name
  // Validates the Policy.name and verifies if it is unique.
  export namespace PostPoliciesValidateName {
    const Body = z.string();
    /*
 Params
'id'?:Schemas.UUID,
body: Body
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/validate-name';
        const query = {};
        if (params.id !== undefined) {
            query.id = params.id;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 409),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{id}
  // Retrieve a single policy for a customer by its id
  export namespace GetPoliciesById {
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.Policy, 'Policy', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // DELETE /policies/{id}
  // Delete a single policy for a customer by its id
  export namespace DeletePoliciesById {
    /*
 Params
'id':Schemas.UUID
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{id}'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404)
            ]
        })
        .build();
    };
  }
  // POST /policies/{id}/enabled
  // Enable/disable a policy
  export namespace PostPoliciesByIdEnabled {
    const Enabled = z.boolean();
    /*
 Params
'id':Schemas.UUID,
'enabled'?:Enabled
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{id}/enabled'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        if (params.enabled !== undefined) {
            query.enabled = params.enabled;
        }

        return actionBuilder('POST', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // GET /policies/{id}/history/trigger
  // Retrieve the trigger history of a single policy
  export namespace GetPoliciesByIdHistoryTrigger {
    const FilterOpId = z.enum([ 'equal', 'not_equal', 'like' ]);
    const FilterOpName = z.enum([ 'equal', 'like', 'not_equal' ]);
    const FilterId = z.string();
    const FilterName = z.string();
    const Limit = z.number().int();
    const Offset = z.number().int();
    const SortColumn = z.enum([ 'hostName', 'id', 'ctime' ]);
    const SortDirection = z.enum([ 'asc', 'desc' ]);
    /*
 Params
'id':Schemas.UUID,
'filterOpId'?:FilterOpId,
'filterOpName'?:FilterOpName,
'filterId'?:FilterId,
'filterName'?:FilterName,
'limit'?:Limit,
'offset'?:Offset,
'sortColumn'?:SortColumn,
'sortDirection'?:SortDirection
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{id}/history/trigger'.replace(
            '{id}',
            params.id.toString()
        );
        const query = {};
        if (params.filterOpId !== undefined) {
            query['filter:op[id]'] = params.filterOpId;
        }

        if (params.filterOpName !== undefined) {
            query['filter:op[name]'] = params.filterOpName;
        }

        if (params.filterId !== undefined) {
            query['filter[id]'] = params.filterId;
        }

        if (params.filterName !== undefined) {
            query['filter[name]'] = params.filterName;
        }

        if (params.limit !== undefined) {
            query.limit = params.limit;
        }

        if (params.offset !== undefined) {
            query.offset = params.offset;
        }

        if (params.sortColumn !== undefined) {
            query.sortColumn = params.sortColumn;
        }

        if (params.sortDirection !== undefined) {
            query.sortDirection = params.sortDirection;
        }

        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [
                new ValidateRule(
                    Schemas.PagedResponseOfHistoryItem,
                    'PagedResponseOfHistoryItem',
                    200
                ),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Schemas.__Empty, '__Empty', 500)
            ]
        })
        .build();
    };
  }
  // PUT /policies/{policyId}
  // Update a single policy for a customer by its id
  export namespace PutPoliciesByPolicyId {
    const Dry = z.boolean();
    const Response409 = z.object({
        msg: z.string().optional().nullable()
    });
    /*
 Params
'policyId':Schemas.UUID,
'dry'?:Dry,
body: Schemas.Policy
*/
    export const actionCreator = (params) => {
        const path = '/api/policies/v1.0/policies/{policyId}'.replace(
            '{policyId}',
            params.policyId.toString()
        );
        const query = {};
        if (params.dry !== undefined) {
            query.dry = params.dry;
        }

        return actionBuilder('PUT', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.__Empty, '__Empty', 200),
                new ValidateRule(Schemas.__Empty, '__Empty', 400),
                new ValidateRule(Schemas.__Empty, '__Empty', 403),
                new ValidateRule(Schemas.__Empty, '__Empty', 404),
                new ValidateRule(Response409, 'Response409', 409)
            ]
        })
        .build();
    };
  }
  // GET /status
  export namespace GetStatus {
    export const actionCreator = () => {
        const path = '/api/policies/v1.0/status';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.__Empty, '__Empty', 200) ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/simple-openapi.json execute accepts urls 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidatedResponse } from 'openapi2typescript';
import { Action } from 'react-fetching-library';
import { ValidateRule } from 'openapi2typescript';
import {
    actionBuilder,
    ActionValidatableConfig
} from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Fruit = zodSchemaFruit();
  export type Fruit = z.infer<typeof Fruit>;

  export const Message = zodSchemaMessage();
  export type Message = z.infer<typeof Message>;

  export const SetFruit = zodSchemaSetFruit();
  export type SetFruit = z.infer<typeof SetFruit>;

  function zodSchemaFruit() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string().optional().nullable()
      });
  }

  function zodSchemaMessage() {
      return z.object({
          description: z.string().optional().nullable()
      });
  }

  function zodSchemaSetFruit() {
      return z.array(zodSchemaFruit());
  }
}

export namespace Operations {
  // GET /fruits
  export namespace GetFruits {
    export type Payload =
      | ValidatedResponse<'SetFruit', 200, Schemas.SetFruit>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (): ActionCreator => {
        const path = '/fruits';
        const query = {} as Record<string, any>;
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.SetFruit, 'SetFruit', 200) ]
        })
        .build();
    };
  }
  // POST /fruits
  export namespace PostFruits {
    export interface Params {
      body: Schemas.Fruit;
    }

    export type Payload =
      | ValidatedResponse<'SetFruit', 200, Schemas.SetFruit>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/fruits';
        const query = {} as Record<string, any>;
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Schemas.SetFruit, 'SetFruit', 200) ]
        })
        .build();
    };
  }
  // DELETE /fruits
  export namespace DeleteFruits {
    export interface Params {
      body: Schemas.Fruit;
    }

    export type Payload =
      | ValidatedResponse<'SetFruit', 200, Schemas.SetFruit>
      | ValidatedResponse<'Message', 400, Schemas.Message>
      | ValidatedResponse<'unknown', undefined, unknown>;
    export type ActionCreator = Action<Payload, ActionValidatableConfig>;
    export const actionCreator = (params: Params): ActionCreator => {
        const path = '/fruits';
        const query = {} as Record<string, any>;
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.SetFruit, 'SetFruit', 200),
                new ValidateRule(Schemas.Message, 'Message', 400)
            ]
        })
        .build();
    };
  }
}
"
`;

exports[`src/cli/schema execute for ./tests/__fixtures__/simple-openapi.json execute input file accepts path 1`] = `
"/* eslint-disable */
/**
 * Generated code, DO NOT modify directly.
 */
import * as z from 'zod';
import { ValidateRule } from 'openapi2typescript';
import { actionBuilder } from 'openapi2typescript/react-fetching-library';

export namespace Schemas {
  export const Fruit = zodSchemaFruit();

  export const Message = zodSchemaMessage();

  export const SetFruit = zodSchemaSetFruit();

  function zodSchemaFruit() {
      return z.object({
          description: z.string().optional().nullable(),
          name: z.string().optional().nullable()
      });
  }

  function zodSchemaMessage() {
      return z.object({
          description: z.string().optional().nullable()
      });
  }

  function zodSchemaSetFruit() {
      return z.array(zodSchemaFruit());
  }
}

export namespace Operations {
  // GET /fruits
  export namespace GetFruits {
    export const actionCreator = () => {
        const path = '/fruits';
        const query = {};
        return actionBuilder('GET', path)
        .queryParams(query)
        .config({
            rules: [ new ValidateRule(Schemas.SetFruit, 'SetFruit', 200) ]
        })
        .build();
    };
  }
  // POST /fruits
  export namespace PostFruits {
    /*
 Params
body: Schemas.Fruit
*/
    export const actionCreator = (params) => {
        const path = '/fruits';
        const query = {};
        return actionBuilder('POST', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [ new ValidateRule(Schemas.SetFruit, 'SetFruit', 200) ]
        })
        .build();
    };
  }
  // DELETE /fruits
  export namespace DeleteFruits {
    /*
 Params
body: Schemas.Fruit
*/
    export const actionCreator = (params) => {
        const path = '/fruits';
        const query = {};
        return actionBuilder('DELETE', path)
        .queryParams(query)
        .data(params.body)
        .config({
            rules: [
                new ValidateRule(Schemas.SetFruit, 'SetFruit', 200),
                new ValidateRule(Schemas.Message, 'Message', 400)
            ]
        })
        .build();
    };
  }
}
"
`;
